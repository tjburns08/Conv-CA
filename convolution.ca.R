# Date: December 1, 2017
# Procedure: Convolution for cellular automata
# Purpose: to produce a CA solution to conways game of life

###################### SETUP ###################### 
library(sp)
library(reshape)
library(ggplot2)
library(animation)
library(spatialfil)
library(tidyverse)

###################### FUNCTIONS ######################

# This function comes from the following:
# http://johnramey.net/blog/2011/06/05/conways-game-of-life-in-r-with-ggplot2-and-animation/
grid_to_ggplot <- function(grid) {
    # Permutes the matrix so that melt labels this correctly.
    grid <- grid[seq.int(nrow(grid), 1), ]
    grid <- melt(grid)
    grid$value <- factor(ifelse(grid$value, "Alive", "Dead"))
    p <- ggplot(grid, aes(x=X1, y=X2, z = value, color = value))
    p <- p + geom_tile(aes(fill = value))
    p  + scale_fill_manual(values = c("Dead" = "white", "Alive" = "black"))
}

# Start with a simple bitwise matrix
# Generates random matrix of 0 and 1s
# Args:
#   side: the length of one side
#   prob: vector of two numbers indicating the probability of respective 0 and 1
# Returns: 
#   result: the matrix of 0 and 1 of length "side" and respective probability of "prob"
generate.space <- function(side, prob) {
    result <- matrix(sample(c(0, 1), side^2, replace = TRUE, prob = prob), nrow = side)
    return(result)
}

# Convolution based nn summer
# Generates a kernel to be used across the "space" matrix
# Args:
#   side: the length of the side of the kernel
# Returns:
#   result: a matrix of only 0. 
generate.kernel <- function(side) {
    result <- matrix(rep(0, side^2), nrow = side)
    return(result)
}

# Makes the nn matrix given space and a kernel matrix
# Args:
#   space: the matrix representing the space of the CA
#   kernel: the matrix representing the kernel to be iterated across space
# Returns: 
#   result: the nn matrix generated by the kernal iterating across space
convolution <- function(space, kernel) {
    
    tmp <- space
    # Make sure the kernel stays within bounds of the matrix 
    # Note tha this only really works for an odd numbered matrix
    if(nrow(kernel) %% 2 == 0) {
        stop("Please choose a kernel with an odd number of sides")
    }
    
    # Find the dimensions for the for loop
    start <- nrow(kernel) %/% 2 + 1
    end <- nrow(space) - start
    to.edge <- start - 1
    
    # The loop
    for(i in start:end) {
        for(j in start:end) {
            piece <- space[(j - to.edge):(j + to.edge), (i - to.edge):(i + to.edge)]
            tmp[j, i] <- sum(piece * kernel)
        }
    }
    
    return(tmp)
}



# Implements Conway's game of life rules on a nn matrix
# Args: 
#   m: the original matrix
#   tmp: the nn matrix from the convolution step
# Returns: 
#   m: the next iteration of the original matrix m
gol.rules <- function(m, tmp) {
    m <- ifelse(tmp < 2 & m == 1, 0, m)
    m <- ifelse(tmp > 3 & m == 1, 0, m)
    m <- ifelse((tmp == 2 | tmp == 3) & m == 1, 1, m)
    m <- ifelse(tmp == 3 & m == 0, 1, m)
    return(m)
}


# Runs single iteration of CA
# Args:
#   space: the matrix representing the CA space
#   kernel: the kernel for convolution of space
#   vis: boolean indicating whether this should be graphed
# Returns: 
#   the space matrix after one iteration. Also plots it as needed
gol.iter <- function(space, kernel, vis) {
    tmp <- convolution(space, kernel)
        
    # GOL rules
    space <- gol.rules(space, tmp)
    return(space)
}

# Ring the outside
ring.outside <- function(m, number) {
    for(i in 1:nrow(m)) {
        for(j in 1:nrow(m)) {
            if(i == 1 | j == 1 | i == nrow(m) | j == nrow(m)) {
                m[i, j] <- number
            } 
        }
    }
    return(m)
}


# Randomize
randomize.kernel <- function(m, numbers, probs) {
    for(i in 1:nrow(m)) {
        for(j in 1:nrow(m)) {
            m[i, j] <- sample(numbers, 1, replace = FALSE, prob = probs)
        }
    }
    return(m)
}

# Generates a shuffled kernel with an exact number of sides and number of ones
# Args:
#   side: length/width of matrix
#   num.ones: the number of 1's to be put in the matrix (the rest is zero)
# Returns: 
#   result: the shuffled kernel with the exact number of ones
generate.exact.kernel <- function(side, num.ones) {
    content <- c(rep(1, num.ones), rep(0, side^2 - num.ones))
    content <- sample(content, size = length(content), FALSE)
    result <- matrix(content, nrow = side)
    return(result)
}

###################### PIPELINE ###################### 

# Space
space <- generate.space(side = 100, prob = c(0.9, 0.1))
kernel <- generate.exact.kernel(side = 5, num.ones = 6)



sapply(ca.list, sum)
age.of.universe <- 100
ca.battery <- lapply(1:age.of.universe, function(i) {
    print(i)
    space <- generate.space(side = 100, prob = c(0.5, 0.5))
    kernel <- generate.exact.kernel(side = 5, num.ones = 6)
    ntimes <- 1000
    # Sum up the number of populated squares
    ca.list <- lapply(1:ntimes, function(i) {
        space <<- gol.iter(space = space, kernel = kernel, vis = FALSE) 
        return(space)
    }) 
    
    result <- sapply(ca.list, sum)
    return(list(space = space, kernel = kernel, sum.vector = result))
})


ca.summary <- sapply(ca.battery, function(i) {
    sum.vector <- i$sum.vector
    return(sum.vector[length(sum.vector)])
})

of.interest <- which(ca.summary > 300 & ca.summary < 1000)


# Produce plots
ntimes <- 1000
space <- generate.space(side = 100, prob = c(0.5, 0.5))
kernel <- gol
ca.plot.list <- lapply(1:ntimes, function(i) {
    space <<- gol.iter(space = space, kernel = kernel, vis = FALSE) 
    p <- grid_to_ggplot(space)
    return(p)
}) 




# Conclusion: Kernel-based CA can potentially add a variety of life-like CA that 
# was previously difficult to get. 

# Intresting kernels:
gol <- matrix(c(1, 1, 1, 1, 0, 1, 1, 1, 1), nrow = 3)
jellyfish <- matrix(c(1, 2, 1, 1, 0, 1, 1, 1, 1), nrow = 3)
stack <- matrix(c(1, 2, 1, 1, 0, 1, 1, 2, 1), nrow = 3)
bacteria <- matrix(c(1, 2, 1, 2, 0, 1, 1, 2, 1), nrow = 3)
exp.block <- matrix(c(1, 2, 1, 2, 0, 2, 1, 2, 1), nrow = 3)
q.mark <- matrix(c(2, 1, 1, 1, 0, 1, 1, 1, 1), nrow = 3)
osc.colon <- matrix(c(2, 1, 1, 1, 0, 1, 1, 1, 2), nrow = 3)

# Quantum
spooky.action <- generate.kernel(5) %>% ring.outside(., 1)



